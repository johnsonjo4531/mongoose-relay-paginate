"use strict";(self.webpackChunkmongoose_relay_paginate=self.webpackChunkmongoose_relay_paginate||[]).push([[305],{4110:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>g,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var o=t(5893),r=t(1151);const i={},a=void 0,s={id:"Changelog",title:"Changelog",description:"v5.0.0 to v6.0.0",source:"@site/docs/Changelog.md",sourceDirName:".",slug:"/Changelog",permalink:"/mongoose-relay-paginate/docs/Changelog",draft:!1,unlisted:!1,editUrl:"https://github.com/johnsonjo4531/mongoose-relay-paginate/tree/main/packages/create-docusaurus/templates/shared/docs/Changelog.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Paging with Cursors",permalink:"/mongoose-relay-paginate/docs/paging"},next:{title:"Compatibility",permalink:"/mongoose-relay-paginate/docs/compatibility"}},l={},d=[{value:"v5.0.0 to v6.0.0",id:"v500-to-v600",level:2},{value:"API Breaking Changes",id:"api-breaking-changes",level:3},{value:"Alternative solutions to the above",id:"alternative-solutions-to-the-above",level:3},{value:"pageInfo.count",id:"pageinfocount",level:4},{value:"toAggregate",id:"toaggregate",level:4},{value:"v4.0.0 to v5.0.0",id:"v400-to-v500",level:2},{value:"Registering the plugin",id:"registering-the-plugin",level:3},{value:"Sending in types",id:"sending-in-types",level:3}];function c(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"v500-to-v600",children:"v5.0.0 to v6.0.0"}),"\n",(0,o.jsx)(n.h3,{id:"api-breaking-changes",children:"API Breaking Changes"}),"\n",(0,o.jsxs)(n.p,{children:["Due to performance reasons anything in this plugin that was dependant on getting Query.countDocuments() or Aggregate.count() (that includes the ",(0,o.jsx)(n.code,{children:"$count"})," aggregation operator) for the whole pagination result had to be omitted. That includes:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"count"})," property in the ",(0,o.jsx)(n.code,{children:"RelayResult"}),"'s ",(0,o.jsx)(n.code,{children:"pageInfo"})," which had to use a ",(0,o.jsx)(n.code,{children:"Query.countDocuments()"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"toAggregate"})," method returned from ",(0,o.jsx)(n.code,{children:"aggregateRelayPaginate"})," which had to use an Aggregate ",(0,o.jsx)(n.code,{children:"$count"})," operator"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Sorry if you were dependant on this, but our team at work recently saw very bad performance issues due to the previous."}),"\n",(0,o.jsx)(n.h3,{id:"alternative-solutions-to-the-above",children:"Alternative solutions to the above"}),"\n",(0,o.jsx)(n.h4,{id:"pageinfocount",children:"pageInfo.count"}),"\n",(0,o.jsxs)(n.p,{children:["There is no alternative to the count property that this library used to provide. Also ",(0,o.jsx)(n.code,{children:"count"})," was never spec compliant witht the Relay Connection spec, so it was likely a poor choice to begin with. You could always provide your own external solution to this, but do know that performance will likely be lackluster."]}),"\n",(0,o.jsx)(n.h4,{id:"toaggregate",children:"toAggregate"}),"\n",(0,o.jsxs)(n.p,{children:["Though not the exact same there is now instead a ",(0,o.jsx)(n.code,{children:"toNodesAggregate"})," method. Instead of returning the ",(0,o.jsx)(n.code,{children:"RelayResult"})," it only returns ",(0,o.jsx)(n.code,{children:"RelayResult[nodes]"})," i.e. just the nodes. The following two examples' ",(0,o.jsx)(n.code,{children:"result"}),"s are equivalent between the previous version's ",(0,o.jsx)(n.code,{children:"toAggregate"})," and the new ",(0,o.jsx)(n.code,{children:"toNodesAggregate"}),":"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"toAggregate"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'const result = await UserModel.aggregateRelayPaginate(\n      [{ $sort: { name: 1 } }],\n      {}\n    )\n      .toAggregate()\n      .unwind("$nodes")\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"toNodesAggregate"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const result = await UserModel.aggregateRelayPaginate(\n      [{ $sort: { name: 1 } }],\n      {}\n    )\n      .toNodesAggregate()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"v400-to-v500",children:"v4.0.0 to v5.0.0"}),"\n",(0,o.jsx)(n.h3,{id:"registering-the-plugin",children:"Registering the plugin"}),"\n",(0,o.jsx)(n.p,{children:"v4 allowed this library to automatically register the global mongoose plugin you now have to do this yourself."}),"\n",(0,o.jsx)(n.p,{children:"v5 and after:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// 0. Register the relay paginate plugins.\nplugin(\n  relayPaginatePlugin({\n    // Send in options\n    maxLimit: 100,\n  })\n);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"sending-in-types",children:"Sending in types"}),"\n",(0,o.jsx)(n.p,{children:"Version 4 of this library tried to provide types for you out of the box, but version 5 now requires you to type your own models. This will make maintenance of this library less likely to break between many different changes to TypeScript types i.e. v5 will provide more future proof types."}),"\n",(0,o.jsx)(n.p,{children:"For v5.0.0 to get Mongoose to return the right types:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'// 1. Create an interface representing a document in MongoDB.\ninterface User {\n  _id: mongoose.Types.ObjectId;\n  myId: number;\n  name: string;\n  email: string;\n  avatar?: string;\n}\n\n// 2. Setup various types.\ntype UserModel = Model<User, RelayPaginateQueryHelper> & RelayPaginateStatics;\n\n// 3. Create a Schema corresponding to the document interface.\nconst schema = new Schema<User, UserModel>({\n  myId: Number,\n  name: { type: String, required: true },\n  email: { type: String, required: true },\n  avatar: String,\n});\n\n// 4. Create your Model.\nconst UserModel = model<User, UserModel>("User", schema);\n'})})]})}function g(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>a});var o=t(7294);const r={},i=o.createContext(r);function a(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);
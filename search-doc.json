{"searchDocs":[{"title":"What is cursoring and pagination?","type":0,"sectionRef":"#","url":"/mongoose-relay-paginate/blog/what-is-cursoring","content":"A cursor helps a server to find an item in a database. If you're not exactly sure what that means here's an analogy. It's a lot like when you go to the library and have some information for a specific book. This information you have about the book can help you locate it. A cursor (some information) can be turned into a database object (the book) by finding the first instance of it in the database (the library). Below is a hypothetical example: Cursor -&gt; Some query from a cursor -&gt; DB Object {name: &quot;bob&quot;} -&gt; Some query from a cursor -&gt; {name: &quot;bob&quot;, job: &quot;something&quot;, location: &quot;some place 123rd street&quot;} An example of some query from a cursor, in MongoDB is: const {name, job, location} = await Employee.findOne({name: &quot;bob&quot;}); A database object can be turned into a cursor with a transform of some sort in our case it will be provided by the user. Below is a hypothetical example: DB Object -&gt; some transform to a cursor -&gt; Cursor { name: &quot;bob&quot;, job: &quot;something&quot;, location: &quot;some place 123rd street&quot; } -&gt; some tranform to a cursor -&gt; {name: &quot;bob&quot;} ","keywords":"","version":null},{"title":"Compatibility","type":0,"sectionRef":"#","url":"/mongoose-relay-paginate/docs/compatibility","content":"","keywords":"","version":"Next"},{"title":"Compatible MongoDB versions​","type":1,"pageTitle":"Compatibility","url":"/mongoose-relay-paginate/docs/compatibility#compatible-mongodb-versions","content":" The following versions have been tested together.  mongoose-relay-paginate\tmongoose\tmongodb6.0.0\t`7.x\t8.x` 5.1.0\t`7.x\t8.x` 5.0.0\t7.5.1\t6.1.0 4.0.1\t6.0.0\t4.4.0 ","version":"Next","tagName":"h2"},{"title":"GraphQL Server Example","type":0,"sectionRef":"#","url":"/mongoose-relay-paginate/docs/examples/graphql-example","content":"GraphQL Server Example","keywords":"","version":"Next"},{"title":"Changelog","type":0,"sectionRef":"#","url":"/mongoose-relay-paginate/docs/Changelog","content":"","keywords":"","version":"Next"},{"title":"v5.0.0 to v6.0.0​","type":1,"pageTitle":"Changelog","url":"/mongoose-relay-paginate/docs/Changelog#v500-to-v600","content":" ","version":"Next","tagName":"h2"},{"title":"API Breaking Changes​","type":1,"pageTitle":"Changelog","url":"/mongoose-relay-paginate/docs/Changelog#api-breaking-changes","content":" Due to performance reasons anything in this plugin that was dependant on getting Query.countDocuments() or Aggregate.count() (that includes the $count aggregation operator) for the whole pagination result had to be omitted. That includes:  The count property in the RelayResult's pageInfo which had to use a Query.countDocuments().The toAggregate method returned from aggregateRelayPaginate which had to use an Aggregate $count operator  Sorry if you were dependant on this, but our team at work recently saw very bad performance issues due to the previous.  ","version":"Next","tagName":"h3"},{"title":"Alternative solutions to the above​","type":1,"pageTitle":"Changelog","url":"/mongoose-relay-paginate/docs/Changelog#alternative-solutions-to-the-above","content":" pageInfo.count​  There is no alternative to the count property that this library used to provide. Also count was never spec compliant witht the Relay Connection spec, so it was likely a poor choice to begin with. You could always provide your own external solution to this, but do know that performance will likely be lackluster.  toAggregate​  Though not the exact same there is now instead a toNodesAggregate method. Instead of returning the RelayResult it only returns RelayResult[nodes] i.e. just the nodes. The following two examples' results are equivalent between the previous version's toAggregate and the new toNodesAggregate:  toAggregate  const result = await UserModel.aggregateRelayPaginate( [{ $sort: { name: 1 } }], {} ) .toAggregate() .unwind(&quot;$nodes&quot;)   toNodesAggregate  const result = await UserModel.aggregateRelayPaginate( [{ $sort: { name: 1 } }], {} ) .toNodesAggregate()   ","version":"Next","tagName":"h3"},{"title":"v4.0.0 to v5.0.0​","type":1,"pageTitle":"Changelog","url":"/mongoose-relay-paginate/docs/Changelog#v400-to-v500","content":" ","version":"Next","tagName":"h2"},{"title":"Registering the plugin​","type":1,"pageTitle":"Changelog","url":"/mongoose-relay-paginate/docs/Changelog#registering-the-plugin","content":" v4 allowed this library to automatically register the global mongoose plugin you now have to do this yourself.  v5 and after:  // 0. Register the relay paginate plugins. plugin( relayPaginatePlugin({ // Send in options maxLimit: 100, }) );   ","version":"Next","tagName":"h3"},{"title":"Sending in types​","type":1,"pageTitle":"Changelog","url":"/mongoose-relay-paginate/docs/Changelog#sending-in-types","content":" Version 4 of this library tried to provide types for you out of the box, but version 5 now requires you to type your own models. This will make maintenance of this library less likely to break between many different changes to TypeScript types i.e. v5 will provide more future proof types.  For v5.0.0 to get Mongoose to return the right types:  // 1. Create an interface representing a document in MongoDB. interface User { _id: mongoose.Types.ObjectId; myId: number; name: string; email: string; avatar?: string; } // 2. Setup various types. type UserModel = Model&lt;User, RelayPaginateQueryHelper&gt; &amp; RelayPaginateStatics; // 3. Create a Schema corresponding to the document interface. const schema = new Schema&lt;User, UserModel&gt;({ myId: Number, name: { type: String, required: true }, email: { type: String, required: true }, avatar: String, }); // 4. Create your Model. const UserModel = model&lt;User, UserModel&gt;(&quot;User&quot;, schema);  ","version":"Next","tagName":"h3"},{"title":"NestJS Example","type":0,"sectionRef":"#","url":"/mongoose-relay-paginate/docs/examples/nestjs","content":"NestJS Example See example repo","keywords":"","version":"Next"},{"title":"relayPaginate()","type":0,"sectionRef":"#","url":"/mongoose-relay-paginate/docs/API/relayPaginate","content":"relayPaginate() After familiarizing yourself with the intro and installing. You can then use .relayPaginate() off of any mongoose query you setup following the install process. const result = await UserModel.find() // This is just the default mongoose sort .sort({ _id: -1 }) // We can use the relayPaginate from this library off of any Query. .relayPaginate({ first: 1, }); relayPaginate takes in only one argument and that is its options argument. const doc = new UserModel({ name: &quot;Bill&quot;, email: &quot;bill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, }); const doc2 = new UserModel({ name: &quot;Jill&quot;, email: &quot;jill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, }); const doc3 = new UserModel({ name: &quot;Phill&quot;, email: &quot;Phill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, }); await doc.save(); await doc2.save(); await doc3.save(); const result = await UserModel.find() // We sort by names from a-z .sort({ name: 1 }) .relayPaginate({ // we get the first 2 items only first: 2, // We start getting results only after we have found bill's record after: { name: &quot;Bill&quot; } }); console.log(result.nodes); // Will be an array of Jill and then Phill's object Generally you would want the cursor (represented by your before and after options) to match whatever you are sorting by; a good default if you don't know what you are sorting by is to use the _id field as your cursor as it is the default sort field in mongodb, though this default is unnecessary in newer versions of the library. Generally this is unnecessary to think about as both relayPaginates (the aggregate and non-aggregate) should return to you start cursors and end cursors to paginate by in your before and after. The before and after options, if provided, have to fit atleast the shape of the sort in order to return the proper output. So if your sort was by { name: 1 } the following would be good and bad examples. // good after cursor since it includes name { after: { name: &quot;Bill&quot; } }; // still good after cursor since it includes name (though // the email is unneccessary, it is both ignored and // completely fine to send in.) { after: { name: &quot;Jill&quot;, email: &quot;jill@example.com&quot; } }; // Bad example of an after cursor does not include a name... // which is the field(s) to sort by. { after: { email: &quot;bill@example.com&quot; } }; // Good example of an after cursor as it again includes the name. // Again it also ignores the email and avatar fields' as // they aren't part of the sort. { after: { name: &quot;Bill&quot;, email: &quot;bill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, } }; // Good example of an after cursor as it again includes the name. // Notice how this time the after cursor is a mixture of // both Bill and Jill's information, but since the email is // ignored Bill's record can still be found since it is only // his information in the name field. Again it also ignores // the email and avatar fields' as they aren't part of the sort. { after: { name: &quot;Bill&quot;, email: &quot;jill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, } }; All the above good examples should also work with the before cursors and the bad examples would not work with them. If your sort was by { name: 1, email: 1 } then you would have to include the name, and email field and values in the cursor fields for before and after.","keywords":"","version":"Next"},{"title":"aggregateRelayPaginate()","type":0,"sectionRef":"#","url":"/mongoose-relay-paginate/docs/API/aggregateRelayPaginate","content":"","keywords":"","version":"Next"},{"title":"released in v2.0.0​","type":1,"pageTitle":"aggregateRelayPaginate()","url":"/mongoose-relay-paginate/docs/API/aggregateRelayPaginate#released-in-v200","content":" After familiarizing yourself with the intro and installing.  You can then use .aggregateRelayPaginate() off of any of the model's you setup.  const result = await UserModel.aggregateRelayPaginate( [{ $sort: { _id: -1 } }], { last: 1, before: result.pageInfo.endCursor, } );   aggregateRelayPaginate takes in two arguments the first is its mongoose aggregation pipeline argument and the second is its relayPaginate options argument.  const doc = new UserModel({ name: &quot;Bill&quot;, email: &quot;bill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, }); const doc2 = new UserModel({ name: &quot;Jill&quot;, email: &quot;jill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, }); const doc3 = new UserModel({ name: &quot;Phill&quot;, email: &quot;Phill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, }); await doc.save(); await doc2.save(); await doc3.save(); const result = await UserModel.aggregateRelayPaginate( [ { $sort: { name: 1 } } ], { // we get the first 2 items only first: 2, // We start getting results only after we have found bill's record after: { name: &quot;Bill&quot; } }); console.log(result.nodes); // Will be an array of Jill and then Phill's object   Generally you would want the cursor (represented by your before and after options) to match whatever you are sorting by; a good default if you don't know what you are sorting by is to use the _id field as your cursor as it is the default sort field in mongodb, though this default is unnecessary in newer versions of the library.  Generally this is unnecessary to think about as both relayPaginates (aggregate and non-aggregate) should return to you start cursors and end cursors to paginate by in your before and after.  The before and after options, if provided, have to fit atleast the shape of the sort in order to return the proper output.  So if your sort was by { name: 1 } the following would be good and bad examples.  // good after cursor since it includes name { after: { name: &quot;Bill&quot; } }; // still good after cursor since it includes name (though // the email is unneccessary, it is both ignored and // completely fine to send in.) { after: { name: &quot;Jill&quot;, email: &quot;jill@example.com&quot; } }; // Bad example of an after cursor does not include a name... // which is the field(s) to sort by. { after: { email: &quot;bill@example.com&quot; } }; // Good example of an after cursor as it again includes the name. // Again it also ignores the email and avatar fields' as // they aren't part of the sort. { after: { name: &quot;Bill&quot;, email: &quot;bill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, } }; // Good example of an after cursor as it again includes the name. // Notice how this time the after cursor is a mixture of // both Bill and Jill's information, but since the email is // ignored Bill's record can still be found since it is only // his information in the name field. Again it also ignores // the email and avatar fields' as they aren't part of the sort. { after: { name: &quot;Bill&quot;, email: &quot;jill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, } };   All the above good examples should also work with the before cursors and the bad examples would not work with them.  If your sort was by { name: 1, email: 1 } then you would have to include the name, and email field and values in the cursor fields for before and after. ","version":"Next","tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/mongoose-relay-paginate/docs/installation","content":"","keywords":"","version":"Next"},{"title":"Usage​","type":1,"pageTitle":"Installation","url":"/mongoose-relay-paginate/docs/installation#usage","content":" Now the relayPaginate should be available on your model's mongoose queries, so you can use it as shown below.  const result = await UserModel.find() // sorting by id from largest (most recent)--&gt; to smallest (most early) using mongoose's default sort. .sort({ _id: -1 }) // This library's `relayPaginate` can now be used off your query // after the above setup. .relayPaginate({ first: 1, });   Or use an aggregate query off of your model:  const result = await UserModel // sorting by id from largest--&gt;smallest using mongoose's default sort. .aggregateRelayPaginate([{ $sort: { _id: 1 } }], { first: 1, });   For more details view the docs. ","version":"Next","tagName":"h2"},{"title":"Why would I want cursor based paging?","type":0,"sectionRef":"#","url":"/mongoose-relay-paginate/blog/why-cursor-based-paging","content":"","keywords":"","version":null},{"title":"TLDR; When should I choose cursoring?​","type":1,"pageTitle":"Why would I want cursor based paging?","url":"/mongoose-relay-paginate/blog/why-cursor-based-paging#tldr-when-should-i-choose-cursoring","content":" When your new information is being added to the beggining of your sorted list that is returned from a database.  ","version":null,"tagName":"h2"},{"title":"What are alternatives to cursor based paging?​","type":1,"pageTitle":"Why would I want cursor based paging?","url":"/mongoose-relay-paginate/blog/why-cursor-based-paging#what-are-alternatives-to-cursor-based-paging","content":" Cursor based paging is sometimes just called cursoring so as not to confuse the term with regular non-cursor based paging.  From here on in this blog post I will use paging to refer to non-cursor based paging and cursoring to refer to cursor based paging.  If you don't know what cursoring is read more about cursoring here.  Paging generally uses skip and limit. Paging is usually displayed in individual pages and allows one to move from page to page with something like this:    Whereas Cursoring is usually displayed in an infinite scrolling feed.  The problem with paging is say your pages of items are from newest to oldest, and that you store 20 items on each page. You (the user) are on page 2 and suddenly 20 new items are submitted to the beginning of the list of items. Suddenly now you're on page 3, but the UI still shows you on page 2, so when you click on page 3 nothing would appear to happen.  To avoid this problem we use cursoring. Which instead of keeping track of where you are based off a skip and limit, it keeps track of where you are based off of any single item in the collection and then allows you to ask for things before or after that item. Each single item in a collection can be turned into a cursor, so that you can query other items relative to where that item is in the collection. ","version":null,"tagName":"h2"},{"title":"Intro","type":0,"sectionRef":"#","url":"/mongoose-relay-paginate/docs/intro","content":"","keywords":"","version":"Next"},{"title":"What​","type":1,"pageTitle":"Intro","url":"/mongoose-relay-paginate/docs/intro#what","content":" This library is meant to allow cursor based pagination between the client and the server. In many ways this cursor based way is similar to the way you would use skip and limit.  Cursor based pagination is a technique that is used by the likes of Facebook and Twitter on their Feeds.  Personally I recommend cursor based pagination if you are doing something like an infinite scroll feed. If however you are doing something more like a table of data where you want to select a page of results skip and limit will probably be a better option.  Technical side note: Although if you really need the selection of a page of results you could technically combine the approaches by providing a skip while still using the library's cursor based PagingInfo, and then you'd get the best of both. Although I would suggest using the library's PagingInfo where possible and only reach for skip if you absolutely need it.  ","version":"Next","tagName":"h2"},{"title":"Typical paging with Skip and Limit (without this library)​","type":1,"pageTitle":"Intro","url":"/mongoose-relay-paginate/docs/intro#typical-paging-with-skip-and-limit-without-this-library","content":" Imagine you're building a web api and you want to allow your users to request a collection of data, but you do not want to give them all the data back at once. You would generally reach for two very typical things in mongodb skip and limit, though like everything there are pros and cons to this approach which were explained in the previous section. Basically to use skip and limit you would pass them from your client to your server in an API route. Your API route might accept an ISkipLimit like so:  interface ISkipLimit { skip: number; limit: number; }   Then calling a function like below in your api get route or graphql query:  function findUsers(skipLimit: ISkipLimit): Promise&lt;User[]&gt; { return UserModel.find({ //... Some possible conditions or none is fine too. }).skip(skipLimit.skip).limit(skipLimit.limit).exec(); }   Notice the type returned here is your typical array of users.  Your front end would then have to somehow communicate the ISkipLimit interface to the backend, so it could do the above. You would typically do that with the use of your request's query parameters or the request's body.  ","version":"Next","tagName":"h3"},{"title":"Paging with cursor based pagination instead (with this library)​","type":1,"pageTitle":"Intro","url":"/mongoose-relay-paginate/docs/intro#paging-with-cursor-based-pagination-instead-with-this-library","content":" The pagination process with a cursor is quite a bit more involved to implement from scratch that's where this library comes in, so that the process of using cursor based pagination will be simpler for mongodb users. With this library paginating with cursor based pagination we use the library's provided type PagingInfo to communicate to the server the same logic a typical skip and limit would provide, but the type looks like this instead:  /** Info about how to page forward and backward * * * `first` and `last` are alot like limit in a typical skip and limit scheme. * This is because first and last signify how many elements to return. * You should never supply both `first` and `last` at the same time. * You should either supply one or the other, but not both. * Supplying both will lead to unpredicted behaviour. * * `after` and `before` are more like the typical skip in skip and limit. * This is because after and before signify where the * collection starts and stops searching. * You may supply both the after and before, but your before cursor must be later * in your collection then your after cursor otherwise you will get 0 results. * * @public */ export type PagingInfo&lt;DocType = unknown&gt; = { /** fetch the `first` given number of records */ first?: number; /** fetch the `last` given number of records */ last?: number; /** fetch `after` the given record's cursor */ after?: PagingCursor&lt;DocType&gt; | null | undefined; /** fetch `before` the given record's cursor */ before?: PagingCursor&lt;DocType&gt; | null | undefined; };   You may be wondering what the before and after is and what exactly the PagingCursor type is, but we'll get to that after we show you the return result of the plugin.  So this is now the data used between the client and server to communicate what part of the data we want to return from the query. The first signifies to fetch the given first number of records from the collection. The last signifies to fetch the given last number of records. The after signifies starting from some record's cursor fetch after that record. The before signifies starting from some record's cursor fetch before that record.  This pagingInfo is passed into the .relayPaginate() method that is available on your queries once this library has properly been initialized. So, you would use that in a route like this:  function findUsers(pagingInfo: PagingInfo&lt;User&gt;): Promise&lt;RelayResult&lt;User[]&gt;&gt; { return UserModel.find({ //... Some possible conditions or none is fine too. }).relayPaginate(pagingInfo).exec(); }   But wait the notice the type returned here from the plugin is not just your typical User array (User[]). Instead it is a RelayResult&lt;User[]&gt; which the RelayResult looks like so:  export interface RelayResult&lt;Nodes extends unknown[]&gt; { edges: { node: ElementOfArray&lt;Nodes&gt;; cursor: PagingCursor&lt;ElementOfArray&lt;Nodes&gt;&gt;; }[]; nodes: Nodes; pageInfo: { hasNextPage: boolean; hasPreviousPage: boolean; endCursor?: PagingCursor&lt;ElementOfArray&lt;Nodes&gt;&gt; | null; startCursor?: PagingCursor&lt;ElementOfArray&lt;Nodes&gt;&gt; | null; }; }   So it looks like our User[] is just our relayResult.nodes, so our frontend can use the user array like that, but also there is some other metadata about the paging process being done which would allow our frontend to control the pagination for us (which is why we would send the whole RelayResult&lt;User[]&gt; to the frontend and not just the nodes.). Also if you were being quite observant you may notice that mysterious PagingCursor from our PagingInfo's after and before properties. This is because those cursors can be passed back to our server through the PagingInfo as our before or after cursor. This process of sending the data back into the relayPaginate plugin is outlined in more detail in the Paging page.  ","version":"Next","tagName":"h3"},{"title":"Why did I create this​","type":1,"pageTitle":"Intro","url":"/mongoose-relay-paginate/docs/intro#why-did-i-create-this","content":" Because no existing pagination for mongoose that I can find was all of the following:  Well testedOptimizedCursor basedRelay Compatible  ","version":"Next","tagName":"h2"},{"title":"FAQ​","type":1,"pageTitle":"Intro","url":"/mongoose-relay-paginate/docs/intro#faq","content":" Q Doesn't MongoDB already have a built-in cursoring mechanism, why reinvent the wheel?  A Yes it does already have one, but that is meant to be used between the server and the database where as this library provides the cursoring/paging to be done between the client and the server. ","version":"Next","tagName":"h3"},{"title":"Script Example","type":0,"sectionRef":"#","url":"/mongoose-relay-paginate/docs/examples/script-example","content":"Script Example import { RelayPaginateStatics, RelayPaginateQueryHelper, alterNodeOnResult, relayPaginate, relayPaginatePlugin, } from &quot;mongoose-relay-paginate&quot;; import { Schema, model, connect, Model, plugin } from &quot;mongoose&quot;; import mongoose from &quot;mongoose&quot;; // Connection url const url = &quot;mongodb://localhost:32782&quot;; // Database Name const dbName = &quot;mongo-relay-connection&quot;; // 0. Register the relay paginate plugins. plugin( relayPaginatePlugin({ // Send in options maxLimit: 100, }) ); // 1. Create an interface representing a document in MongoDB. interface User { _id: mongoose.Types.ObjectId; myId: number; name: string; email: string; avatar?: string; } // 2. Setup various types. type UserModel = Model&lt;User, RelayPaginateQueryHelper&gt; &amp; RelayPaginateStatics; // 3. Create a Schema corresponding to the document interface. const schema = new Schema&lt;User, UserModel, MyUserMethods&gt;({ myId: Number, name: { type: String, required: true }, email: { type: String, required: true }, avatar: String, }); // 4. Create your Model. const UserModel = model&lt;User, UserModel&gt;(&quot;User&quot;, schema); async function run(): Promise&lt;void&gt; { // 4. Connect to MongoDB const client = await connect(url, { dbName, }); const doc = new UserModel({ myId: 1, name: &quot;Bill&quot;, email: &quot;bill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, }); const doc2 = new UserModel({ myId: 2, name: &quot;Jill&quot;, email: &quot;jill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, }); const doc3 = new UserModel({ myId: 3, name: &quot;Phill&quot;, email: &quot;Phill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, }); await doc.save(); await doc2.save(); await doc3.save(); const result = await UserModel.find() .sort({ name: -1 }) .relayPaginate({ first: 1, }); console.log(result.nodes); // Will be any array of just Phill's object } ","keywords":"","version":"Next"},{"title":"Paging with Cursors","type":0,"sectionRef":"#","url":"/mongoose-relay-paginate/docs/paging","content":"","keywords":"","version":"Next"},{"title":"Note on relayPaginate vs. aggregateRelayPaginate.​","type":1,"pageTitle":"Paging with Cursors","url":"/mongoose-relay-paginate/docs/paging#note-on-relaypaginate-vs-aggregaterelaypaginate","content":" With relayPaginate and aggregateRelayPaginate they both take the same options for paging, but the only difference is that relayPaginate takes these options in the first argument spot and aggregateRelayPaginate takes them in the second argument spot.  ","version":"Next","tagName":"h2"},{"title":"Data Setup​","type":1,"pageTitle":"Paging with Cursors","url":"/mongoose-relay-paginate/docs/paging#data-setup","content":" First we'll setup some test documents. This is only for illustrative purposes, so you know what documents are in the mongoDB collection for the UserModel.  const doc = new UserModel({ name: &quot;Bill&quot;, email: &quot;bill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, }); const doc2 = new UserModel({ name: &quot;Jill&quot;, email: &quot;jill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, }); const doc3 = new UserModel({ name: &quot;Phill&quot;, email: &quot;Phill@example.com&quot;, avatar: &quot;https://i.imgur.com/dM7Thhn.png&quot;, }); await doc.save(); await doc2.save(); await doc3.save();   ","version":"Next","tagName":"h2"},{"title":"Forward Pagination through using first and after​","type":1,"pageTitle":"Paging with Cursors","url":"/mongoose-relay-paginate/docs/paging#forward-pagination-through-using-first-and-after","content":" Once we have our data setup (as given in the above Data Setup section), we can do our first pagination which is a forward pagination.  We prep by doing our first query which since we are moving forward in the collection we use the first option to grab the first 1 documents.  const result = await UserModel.find() // We sort by names from a-z .sort({ name: 1 }) .relayPaginate({ // we get the first item only (which will be Bill's document) first: 1 }); console.log(result.nodes); // Will be an array of only Bill's document. console.log(result.pageInfo.hasNextPage); // Will return true since there are still more documents that could be queried.   Then we pass it's resultant endCursor to the after argument to get the next page.  const result2 = await UserModel.find() // We sort by names from a-z .sort({ name: 1 }) .relayPaginate({ after: result.pageInfo.endCursor, // we get the first item after Bill's record only (which will be Jill's document) first: 1 }); console.log(result2.nodes); // Will be an array of only Jill's document. console.log(result2.pageInfo.hasNextPage); // Will return true since there are still more documents that could be queried.   We could repeat this process indefinitely until the pageInfo indicates that hasNextPage is false.  const result3 = await UserModel.find() // We sort by names from a-z .sort({ name: 1 }) .relayPaginate({ after: result2.pageInfo.endCursor, // we get the first item after Jill's record only (which will be Phill's document) first: 1 }); console.log(result3.nodes); // Will be an array of only Phill's document. console.log(result3.pageInfo.hasNextPage); // Will return false, since there are no more documents to be queried.   ","version":"Next","tagName":"h2"},{"title":"Backward Pagination through Using last and before​","type":1,"pageTitle":"Paging with Cursors","url":"/mongoose-relay-paginate/docs/paging#backward-pagination-through-using-last-and-before","content":" To cursor backwards we follow a slightly different pattern. Once we have our data setup (as given in the above Data Setup section), we can do our second pagination which is a backward pagination.  We prep by doing our query, which since we are moving backwards we need to use the last option instead of the first option.  const result = await UserModel.find() // We sort by names from a-z .sort({ name: 1 }) .relayPaginate({ // we get the last item only (which will be Phill's document) last: 1 }); console.log(result.nodes); // Will be an array of only Phill's document. console.log(result.pageInfo.hasPreviousPage); // Will return true since there are still more documents that could be queried.   Then we pass it's resultant startCursor to the before argument to get the previous page.  const result2 = await UserModel.find() // We sort by names from a-z .sort({ name: 1 }) .relayPaginate({ before: result.pageInfo.startCursor, // we get the last item before Bill's record only (which will be Jill's document) last: 1 }); console.log(result2.nodes); // Will be an array of only Jill's document. console.log(result2.pageInfo.hasPreviousPage); // Will return true since there are still more documents that could be queried.   We could repeat this process indefinitely until the pageInfo indicates that hasPreviousPage is false.  const result3 = await UserModel.find() // We sort by names from a-z .sort({ name: 1 }) .relayPaginate({ before: result2.pageInfo.endCursor, // we get the last item before Jill's record only (which will be Bill's document) last: 1 }); console.log(result3.nodes); // Will be an array of only Bill's document. console.log(result3.pageInfo.hasPreviousPage); // Will return false, since there are no more documents to be queried.   ","version":"Next","tagName":"h2"},{"title":"Last doesn't change sort-order​","type":1,"pageTitle":"Paging with Cursors","url":"/mongoose-relay-paginate/docs/paging#last-doesnt-change-sort-order","content":" Last doesn't change the sort order of the documents returned from the query. They are in the order the query defined them. Which means your results for first and last could be the same if you somehow query the whole collection. For example, if you had the documents like we do of with names of Bill, Jill, and Phill like we do above and sort by name ascending (A to Z). You would get the following (possibly unexpected) results from using first and then using last.  Using First:  const result = await UserModel.find() // We sort by names from a-z .sort({ name: 1 }) .relayPaginate({ first: 100 }); console.log(result.nodes.map(x =&gt; x.name)); // [&quot;Bill&quot;, &quot;Jill&quot;, &quot;Phill&quot;]   Using Last you get the same result.  const result = await UserModel.find() // We sort by names from a-z .sort({ name: 1 }) .relayPaginate({ last: 100 }); console.log(result.nodes.map(x =&gt; x.name)); // [&quot;Bill&quot;, &quot;Jill&quot;, &quot;Phill&quot;]  ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}